<!--
Aspect which manages selection semantics for items in a list.

@element basic-item-selection
-->

<link rel="import" href="../basic-aspect/basic-aspect.html">

<script>
/**
 * Fires when a new item has been selected.
 *
 * @event selected-item-changed
 * @param detail.selectedItem The new selected item.
 * @param detail.previousItem The previously selected item.
 */


Polymer({

  behaviors: [Basic.Aspect],

  // Default implementation will be overwritten with collective method.
  applySelection: function(item, selected) {},

  contribute: {

    itemAdded: function(item) {
      this.applySelection(item, item === this.selectedItem);
    },

    itemsChanged: function() {
      var index = this.items.indexOf(this.selectedItem);
      if (index < 0) {
        // Selected item is no longer in the current set of items.
        this.selectedItem = null;
        if (this.selectionRequired) {
          // Ensure selection, but do this in the next tick to give other
          // aspects a chance to do their own itemsChanged work.
          setTimeout(function() {
            this._ensureSelection();
          }.bind(this));
        }
      }
    },

    get selectedItem() {
      return this._selectedItem;
    },

    /**
     * The currently selected item, or null if there is no selection.
     *
     * @property selectedItem
     * @type Object
     */
    // TODO: Confirm item is in items before selecting.
    set selectedItem(item) {
      var previousItem = this._selectedItem;
      if (previousItem) {
        // Remove previous selection.
        this.applySelection(previousItem, false);
      }
      this._selectedItem = item;
      if (item) {
        this.applySelection(item, true);
      }

      var event = new CustomEvent('selected-item-changed', {
        bubbles: true,
        detail: {
          selectedItem: item,
          previousItem: previousItem
        }
      });
      this.dispatchEvent(event);
    },

    /**
     * The index of the item which is currently selected, or -1 if there is no
     * selection.
     *
     * @property selectedIndex
     * @type Number
     */
    get selectedIndex() {
      var selectedItem = this.selectedItem;

      if (selectedItem == null) {
        return -1;
      }

      // TODO: Memoize
      var index = this.indexOfItem(selectedItem);

      // If index = -1, selection wasn't found. Most likely cause is that the
      // DOM was manipulated from underneath us.
      // TODO: Once we track content changes, turn this into an exception.
      return index;
    },

    set selectedIndex(index) {
      var items = this.items;
      var item;
      if (index < 0 || items.length === 0) {
        item = null;
      } else {
        item = items[index];
      }
      this.selectedItem = item;
    },

    /**
     * Select the first item in the list.
     *
     * @method selectFirst
     */
    selectFirst: function() {
      return this._selectIndex(0);
    },

    /**
     * Select the last item in the list.
     *
     * @method selectLast
     */
    selectLast: function() {
      return this._selectIndex(this.items.length - 1);
    },

    /**
     * Select the next item in the list.
     *
     * @method selectNext
     */
    selectNext: function() {
      return this._selectIndex(this.selectedIndex + 1);
    },

    /**
     * Select the previous item in the list.
     *
     * @method selectPrevious
     */
    selectPrevious: function() {
      return this._selectIndex(this.selectedIndex - 1);
    }

  },

  is: 'basic-item-selection',

  properties: {
    selectionRequired: {
      type: Boolean,
      observer: 'selectionRequiredChanged',
      value: false
    }
  },

  selectionRequiredChanged: function(selectionRequired, oldSelectionRequired) {
    if (selectionRequired && !oldSelectionRequired) {
      this._ensureSelection();
    }
  },

  // If no item is selected, select a default item.
  // TODO: If the previously-selected item has been deleted, try to select an
  // item adjacent to the position it held.
  _ensureSelection: function() {
    if (!this.selectedItem && this.items && this.items.length > 0) {
      this.selectedIndex = 0;
    }
  },

  // Ensure the given index is within bounds, and select it if it's not already
  // selected.
  _selectIndex: function(index) {
    var boundedIndex = Math.max(Math.min(index, this.items.length - 1), 0);
    var previousIndex = this.selectedIndex;
    if (previousIndex !== boundedIndex) {
      this.selectedIndex = boundedIndex;
      return true;
    } else {
      return false;
    }
  },

  _selectedItem: null

});
</script>
